= Active Job Style Guide

This style guide is a list of best practices working with Ruby background jobs using Active Job with Sidekiq backend.

Despite the common belief, they work quite well together if you follow the guidelines.

[#active-record-models-as-arguments]
=== Active Record Models as Arguments

Pass Active Record models as arguments; do not pass by id.
Active Job automatically serializes and deserializes Active Record models using https://edgeguides.rubyonrails.org/active_job_basics.html#globalid[GlobalID], and manual deserialization of the models is not necessary.

GlobalID handles model class mismatches properly.

Deserialization errors are reported to error tracking.

[source,ruby]
----
# bad - passing by id
# Deserialization error is reported, the job *is* scheduled for retry.
class SomeJob < ApplicationJob
  def perform(model_id)
    model = Model.find(model_id)
    do_something_with(model)
  end
end

# bad - model mismatch
class SomeJob < ApplicationJob
  def perform(model_id)
    Model.find(model_id)
    # ...
  end
end

# Will try to fetch a Model using another model class, e.g. User's id.
SomeJob.perform_later(user.id)

# acceptable - passing by id
# Deserialization error is reported, the job is *not* scheduled for retry.
class SomeJob < ApplicationJob
  def perform(model_id)
    model = Model.find(model_id)
    do_something_with(model)
  rescue ActiveRecord::RecordNotFound
    Rollbar.warning('Not found')
  end
end

# good - passing with GlobalID
# Deserialization error is reported, the job is *not* scheduled for retry.
class SomeJob < ApplicationJob
  def perform(model)
    do_something_with(model)
  end
end
----

WARNING: Do not replace one style with another, use a transitional period to let all jobs scheduled with ids to be processed.
Use a helper to temporarily support both numeric and GlobalID arguments.

[source,ruby]
----
class SomeJob < ApplicationJob
  include TransitionHelper

  def perform(model)
    # TODO: remove this when all jobs with numeric id arguments are processed
    model = fetch(model, Model)
    do_something_with(model)
  end
end

module TransitionHelper
  def fetch(id_or_object, model_class)
    case id_or_object
    when Numeric
      model_class.find(id_or_object)
    when model_class
      id_or_object
    else
      fail "Object type mismatch #{model_class}, #{id_or_object}"
    end
  end
end
----

[#queue-assignments]
=== Queue Assignments

Explicitly specify a queue to be used in job classes.
Make sure the queue is on the https://github.com/mperham/sidekiq/wiki/Advanced-Options#queues[list of processed queues].

Putting all jobs into one basket comes with a risk of more urgent jobs being executed with a significant delay.
Do not put slow and fast jobs together in one queue.
Do not put urgent and non-urgent jobs together in one queue.

[source,ruby]
----
# bad - no queue specified
class SomeJob < ApplicationJob
  def perform
    # ...
  end
end

# bad - the wrong queue specified
class SomeJob < ApplicationJob
  queue_as :hgh_prioriti # nonexistent queue specified

  def perform
    # ...
  end
end

# good
class SomeJob < ApplicationJob
  queue_as :high_priority

  def perform
    # ...
  end
end
----

[#idempotency]
=== Idempotency

Ideally, jobs should be idempotent, meaning there should be no bad side effects of them running more than once.
Sidekiq only guarantees that the jobs will run https://github.com/mperham/sidekiq/wiki/Best-Practices#2-make-your-job-idempotent-and-transactional[at least once], but not necessarily exactly once.

Even jobs that do not fail due to errors https://github.com/mperham/sidekiq/wiki/FAQ#what-happens-to-long-running-jobs-when-sidekiq-restarts[might be interrupted] during https://github.com/mperham/sidekiq/wiki/Deployment#overview[non-rolling-release deployments].

[source,ruby]
----
class UserNotificationJob < ApplicationJob
  def perform(user)
    send_email_to(user) unless already_notified?(user)
  end
end
----

[#threads]
=== Threads

Do not use threads in your jobs.
Spawn jobs instead.
Spinning up a thread in a job leads to opening a new database connection, and the connections are easily exhausted, up to the point when the webserver is down.

[source,ruby]
----
# bad - consumes all available connections
class SomeJob < ApplicationJob
  def perform
    User.find_each |user|
      Thread.new do
        ExternalService.update(user)
      end
    end
  end
end

# good
class SomeJob < ApplicationJob
  def perform(user)
    ExternalService.update(user)
  end
end

User.find_each |user|
  SomeJob.perform_later(user)
end
----

[#retries]
=== Retries

Avoid using https://edgeguides.rubyonrails.org/active_job_basics.html#exceptions[ActiveJob's built-in `retry_on`] or `ActiveJob::Retry` (`activejob-retry` gem).
Use Sidekiq retries, which are also available from within Active Job with Sidekiq 6+.

Do not hide or extract job retry mechanisms.
Keep retries directives visible in the jobs.

[source,ruby]
----
# bad - makes three attempts without submitting to Rollbar,
# fails and relies on Sidekiq's retry that would also make several
# retry attempts, submitting each of the failures to Rollbar.
class SomeJob < ApplicationJob
  retry_on ThirdParty::Api::Errors::SomeError, wait: 1.minute, attempts: 3

  def perform(user)
    # ...
  end
end

# bad - it's not clear upfront if the job will be retried or not
class SomeJob < ApplicationJob
  include ReliableJob

  def perform(user)
    # ...
  end
end

# good - Sidekiq deals with retries
class SomeJob < ApplicationJob
  sidekiq_options retry: 3

  def perform(user)
    # ...
  end
end
----

==== Batches

Always use retries for jobs that are executed in batches, otherwise, the batch will never succeed.

[#mind-transactions]
=== Mind Transactions

Background processing of a scheduled job may happen sooner than you expect.
Make sure to https://github.com/mperham/sidekiq/wiki/Problems-and-Troubleshooting#cannot-find-modelname-with-id12345[only schedule jobs when the transaction has been committed].

[source,ruby]
----
# bad - job may perform earlier than the transaction is committed
User.transaction do
  users_params.each do |user_params|
    user = User.create!(user_params)
    NotifyUserJob.perform_later(user)
  end
end

# good
users = User.transaction do
          users_params.map do |user_params|
            User.create!(user_params)
          end
        end
users.each { |user| NotifyUserJob.perform_later(user) }
----

[#local-performance-testing]
=== Local Performance Testing

Due to Rails auto-reloading, Sidekiq jobs are executed one-by-one, with no parallelism.
That may be confusing.

Run Sidekiq in an environment that has `eager_load` set to `true`, or with the following flags to circumvent this behavior:

[source,sh]
----
EAGER_LOAD=true ALLOW_CONCURRENCY=true bundle exec sidekiq
----

[#critical-jobs]
=== Critical Jobs

Background job processing may be down for a prolonged period (minutes), e.g. during a failed deployment or a burst of other jobs.

Consider running time-critical and mission-critical jobs in-process.

[#business-logic-in-jobs]
=== Business Logic in Jobs

Do not put business logic to jobs; extract it.

[source, ruby]
----
# bad
class SendUserAgreementJob < ApplicationJob
  # Convenient method to check if preconditions are satisfied to avoid
  # scheduling unnecessary jobs.
  def self.perform_later_if_applies(user)
    job = new(user)
    return unless job.satisfy_preconditions?

    job.enqueue
  end

  def perform(user)
    @user = user
    return unless satisfy_preconditions?

    agreement = agreement_for(user: user)
    AgreementMailer.deliver_now(agreement)
  end

  def satisfy_preconditions?
    legal_agreement_signed? &&
      !user.removed? &&
      !user.referral? &&
      !(user.active? || user.pending?) &&
      !user.has_flag?(:on_hold)
  end

  private

  attr_reader :user

  # business logic
end

# good - business logic is not coupled to the job
class SendUserAgreementJob < ApplicationJob
  def perform(user)
    agreement = agreement_for(user: user)
    AgreementMailer.deliver_now(agreement)
  end
end

SendUserAgreementJob.perform_later(user) if satisfy_preconditions?
----
