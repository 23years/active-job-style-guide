= Active Job Style Guide

This style guide is a list of best practices working with Ruby background jobs using Active Job with Sidekiq backend.

Despite the common belief, they work quite well together if you follow the guidelines.

[#active-record-models-as-arguments]
=== Active Record Models as Arguments

Pass Active Record models as arguments; do not pass by id.
Active Job automatically serializes and deserializes Active Record models using https://edgeguides.rubyonrails.org/active_job_basics.html#globalid[GlobalID], and manual deserialization of the models is not necessary.

GlobalID handles model class mismatches properly.

Deserialization errors are reported to error tracking.

[source,ruby]
----
# bad - passing by id
# Deserialization error is reported, the job *is* scheduled for retry.
class SomeJob < ApplicationJob
  def perform(model_id)
    model = Model.find(model_id)
    do_something_with(model)
  end
end

# bad - model mismatch
class SomeJob < ApplicationJob
  def perform(model_id)
    Model.find(model_id)
    # ...
  end
end

# Will try to fetch a Model using another model class, e.g. User's id.
SomeJob.perform_later(user.id)

# acceptable - passing by id
# Deserialization error is reported, the job is *not* scheduled for retry.
class SomeJob < ApplicationJob
  def perform(model_id)
    model = Model.find(model_id)
    do_something_with(model)
  rescue ActiveRecord::RecordNotFound
    Rollbar.warning('Not found')
  end
end

# good - passing with GlobalID
# Deserialization error is reported, the job is *not* scheduled for retry.
class SomeJob < ApplicationJob
  def perform(model)
    do_something_with(model)
  end
end
----

WARNING: Do not replace one style with another, use a transitional period to let all jobs scheduled with ids to be processed.
Use a helper to temporarily support both numeric and GlobalID arguments.

[source,ruby]
----
class SomeJob < ApplicationJob
  include TransitionHelper

  def perform(model)
    # TODO: remove this when all jobs with numeric id arguments are processed
    model = fetch(model, Model)
    do_something_with(model)
  end
end

module TransitionHelper
  def fetch(id_or_object, model_class)
    case id_or_object
    when Numeric
      model_class.find(id_or_object)
    when model_class
      id_or_object
    else
      fail "Object type mismatch #{model_class}, #{id_or_object}"
    end
  end
end
----

[#long-running-one-off-jobs]
=== Long-running One-off Jobs

Avoid using self-scheduling jobs.
Prefer using https://github.com/mperham/sidekiq/wiki/Batches[Sidekiq Batches] to split the workload.

[source,ruby]
----
# bad
class BackfillMissingDataJob < ApplicationJob
  BATCH_SIZE = 20
  def perform(offset = 0)
    models = Model.where(attribute: nil)
      .order(:id).offset(offset).limit(BATCH_SIZE)
    return if models.empty?

    models.each do |model|
      model.update!(attribute: for(model))
    end
    self.class.perform_later(offset + BATCH_SIZE)
  end
end

# good
class BackfillMissingDataJob < ApplicationJob
  def self.run_batch
    Sidekiq::Batch.new.jobs do
      Model.where(attribute: nil)
        .find_in_batches(20) do |models|
        BackfillMissingDataJob.perform_later(models)
      end
    end
  end

  def perform(models)
    models.each do |model|
      model.update!(attribute: for(model))
    end
  end
end
----

[#api-rate-limited-operations]
=== API Rate-limited Operations

Most third-party APIs have usage limits and will fail if there are too many calls in a period of time.
Use rate limiting in jobs that make such external calls.

Never rely on the amount of the jobs to be executed.
Even if you schedule jobs to be executed at a specific moment of time, they might be actually executed all at once, due to e.g. traffic jam in job processing.
Use https://github.com/mperham/sidekiq/wiki/Ent-Rate-Limiting[Enterprise Rate Limiting].
Use the strategy (Concurrent, Bucket, Window) that is most suitable to the specific API rate limiting.

[source,ruby]
----
# bad
class UpdateExternalDataJob < ApplicationJob
  retry_on ThirdParty::Api::Errors::TooManyRequestsError, wait: 1.minute, attempts: 3

  def perform(user)
    new_attribute = ThirdParty::Api.get_attribute(user.external_id)
    user.update!(attribute: new_attribute)
  end
end

User.where.not(external_id: nil)
  .find_in_batches.with_index do |group_number, users|
  users.each do |user|
    UpdateExternalDataJob
      .set(wait: group_number.minutes)
      .perform_later(users)
    end
end

# good
class UpdateExternalDataJob < ApplicationJob
  LIMITER = Sidekiq::Limiter.window('third-party-attribute-update', 20, :minute, wait_timeout: 0)

  def perform(user)
    LIMITER.within_limit do
      new_attribute = ThirdParty::Api.get_attribute(user.external_id)
      user.update!(attribute: new_attribute)
    end
  end
end

User.where.not(external_id: nil).find_each do |user|
  UpdateExternalDataJob.perform_later(user)
end
----
